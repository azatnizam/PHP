Тестируем запрос

-- Запрос 3: Выбрать сумму билетов за сентябрь 2020
SELECT sum(price) 
FROM public.tickets
WHERE date_buy >= '2020-09-01' AND date_buy <= '2020-09-30';

Создаем таблицу без индексов

CREATE TABLE public.tickets (
  ticket_id serial NOT NULL CONSTRAINT ticket_id_pk PRIMARY KEY,
  timetable_id int4 NOT NULL CONSTRAINT timetable_id_timetables_tickets_fk REFERENCES public.timetables,
  place_id int4 NOT NULL CONSTRAINT place_id_places_fk REFERENCES public.places,
  date_buy date,
  price numeric(6,2) NOT NULL
);

Еще понадобится таблицы timetables, places но в запросе они не участвуют, можно не учитывать

1. Заполняем таблицу на 10000 строк

Генерируем данные

INSERT INTO public.tickets (ticket_id, timetable_id, place_id, date_buy, price)
SELECT
    gs.id,
    ((random()*99)::integer),
    ((random()*199)::integer),
    date(now() + (text(round(random()*365)-90)||' day')::interval),
    (random()*600 + 500)
FROM generate_series(1,10000) as gs(id);

План запроса:
Aggregate  (cost=216.16..216.17 rows=1 width=32)
  ->  Seq Scan on tickets  (cost=0.00..214.00 rows=863 width=6)
        Filter: ((date_buy >= '2020-09-01'::date) AND (date_buy <= '2020-09-30'::date))

Добавляем индексы

CREATE INDEX tickets_date_buy_index ON public.tickets (date_buy);
CREATE INDEX tickets_price_index ON public.tickets (price);

План запроса:
Aggregate  (cost=100.24..100.25 rows=1 width=32)
  ->  Bitmap Heap Scan on tickets  (cost=21.13..98.08 rows=863 width=6)
        Recheck Cond: ((date_buy >= '2020-09-01'::date) AND (date_buy <= '2020-09-30'::date))
        ->  Bitmap Index Scan on tickets_date_buy_index  (cost=0.00..20.92 rows=863 width=0)
              Index Cond: ((date_buy >= '2020-09-01'::date) AND (date_buy <= '2020-09-30'::date))


Результат улучшился

Удаляем индексы и данные:
DELETE FROM public.tickets;
DROP INDEX tickets_date_buy_index;
DROP INDEX tickets_price_index;


2. Заполняем таблицу на 1000000 строк
Попробуем сначала создать индексы а потом удалять

Генерируем данные

INSERT INTO public.tickets (ticket_id, timetable_id, place_id, date_buy, price)
SELECT
    gs.id,
    ((random()*99)::integer),
    ((random()*199)::integer),
    date(now() + (text(round(random()*365)-90)||' day')::interval),
    (random()*600 + 500)
FROM generate_series(1,1000000) as gs(id);

План запроса:
Finalize Aggregate  (cost=13807.80..13807.81 rows=1 width=32)
  ->  Gather  (cost=13807.57..13807.78 rows=2 width=32)
        Workers Planned: 2
        ->  Partial Aggregate  (cost=12807.57..12807.58 rows=1 width=32)
              ->  Parallel Seq Scan on tickets  (cost=0.00..12717.20 rows=36148 width=6)
                    Filter: ((date_buy >= '2020-09-01'::date) AND (date_buy <= '2020-09-30'::date))


Добавляем индексы

CREATE INDEX tickets_date_buy_index ON public.tickets (date_buy);
CREATE INDEX tickets_price_index ON public.tickets (price);

План запроса:
Aggregate  (cost=9622.97..9622.98 rows=1 width=32)
  ->  Bitmap Heap Scan on tickets  (cost=1748.27..9417.16 rows=82326 width=6)
        Recheck Cond: ((date_buy >= '2020-09-01'::date) AND (date_buy <= '2020-09-30'::date))
        ->  Bitmap Index Scan on tickets_date_buy_index  (cost=0.00..1727.68 rows=82326 width=0)
              Index Cond: ((date_buy >= '2020-09-01'::date) AND (date_buy <= '2020-09-30'::date))


Скорость увеличилась но не сильно, всего в 13807.80 / 9622.97 = 1,43 раза


Как можно увеличить скорость:
Если нас часто будет интересовать сумма за месяц (скорее всего будет), то можно сделать дополнительное поле
Вычисляемые поля появились в postgresql 12, в более ранних версиях можно делать триггеры
Но в данном случае интересует производительность, поэтому можем заполнить руками

alter table tickets
  add month int;

CREATE INDEX tickets_month_index ON public.tickets (month);

EXPLAIN SELECT sum(price) 
FROM public.tickets
WHERE month = 9;

Aggregate  (cost=6492.24..6492.25 rows=1 width=32)
  ->  Bitmap Heap Scan on tickets  (cost=95.17..6479.74 rows=5000 width=6)
        Recheck Cond: (month = 9)
        ->  Bitmap Index Scan on tickets_month_index  (cost=0.00..93.92 rows=5000 width=0)
              Index Cond: (month = 9)

Скорость увеличилась в 13807.80 / 6492.2 = 2,13 раза