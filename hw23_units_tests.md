# Модульные тесты  
##### Отрицательное ожидание
Если JSON на входе содержит одно или более полей с невалидными данными,
метод должен вернуть ответ с кодом `400` и JSON с полем `error`, в котором 
содержится массив с названиями невалидных полей.
- Массив `error` в ответе должен содержать `card_number`, если `card_number`:  
    - содержит кол-во символов не равное 16   
    - содержит хотя бы один не цифровой символ
- Массив `error` в ответе должен содержать `card_holder`, если `card_holder`:
    - содержит символы, кроме A-Z, пробела и дефиса
    - начинается с дефиса
    - содержит дефис после пробела
    - кол-во пробелов более одного  
- Массив `error` в ответе должен содержать `card_expiration`, если `card_expiration`:
    - не является корректной датой в формате мм/гг (/[01]{1}[0-9]{2}\/[\d]{2}/)
    - вычисляемая дата на месяц меньше текущей (01/20 например)
- Массив `error` в ответе должен содержать `cvv`, если `cvv`:  
    - содержит кол-во символов не равное 3
    - содержит хотя бы один нечисловой символ
- Массив `error` в ответе должен содержать `sum`, если `sum`:
    - равно 0,00
    
_Примечание: так как в задаче не указаны ограничения на сумму, будем считать, что
сумма перевода не ограничена сверху, и может быть минимум 0,01 у.е., ошибка 
недопустимой суммы будет пробрасываться от сервиса «А»_

##### Положительное ожидание
- Метод должен вернуть ответ с кодом `200` или с кодом 
  `403` и заголовком `X-Error-Code: {\d внутренний код ошибки}`, или с кодом 
  `500 Service Temporaraly Unavailable`, если:
    - `card_number` содержит 16 цифр,
    - `card_holder` содержит фамилию и имя, записанные латиницей через пробел с 
    использованием дефиса в имени.
    - `card_expiration` записано в формате мм/гг текущим месяцем
    - `card_expiration` записано в формате мм/гг следующим месяцем
    - `card_expiration` записано в формате мм/гг ровно через год от текущей даты
    - `cvv` содержит три цифры
    - `sum` содержит значение с дробной частью отличной от нуля
    - `sum` содержит значение с дробной частью равной 00
    
_Примечание: предполагается, что фронт не отправляет запрос на бэк, если 
обязательные поля не заполнены (обязательными являются все поля в примере), 
а так же сам приводит поле `sum` к строке вида 000,00 и не позволяет вводить 
нечисловые значения. Фронт всегда шлёт все поля в JSON теле POST запроса_

# Интеграционные тесты

### Фронт – бэк
- Если от бэка пришёл ответ с кодом 400 и JSON c полем `error` кнопка оплатить
блокируется до изменения указанных полей, а так же:
    - массив `error` содержит значение `card_number`, на странице поле `card_number` 
        должно выделиться красной рамкой;
    - массив `error` содержит значение `card_holder`, на странице поле `card_holder` 
        должно выделиться красной рамкой;
    - массив `error` содержит значение `cvv`, на странице поле `cvv` 
        должно выделиться красной рамкой;
    - массив `error` содержит значение `card_expiration`, на странице поле `card_expiration` 
        должно выделиться красной рамкой; 
    - массив `error` содержит значение `sum`, на странице поле `sum` 
        должно выделиться красной рамкой;
_Проверять разные комбинации, на мой взгляд не имеет смысла в данном случае – 
возможна оценка ответа для 2–3 комбинаций неправильных входных данных_
- Если с бэкэнда вернулся код ошибки 403 - фронт выводит ошибку в alert 
(например: `Оплата не возможна,  проверьте введёные данные` и т.п.)
- Если пришёл ответ с кодом 500 – фронт должен выкинуть alert с текстом
`Оплата временно не доступна, попробуйте произвести оплату позднее`
- Если с бэка вернулся код 200, на странице отображается сообщение
`Вы успешно оплатили фильм, <a href="#watch">начать просмотр</a>`

### Бэк – сервис А
- Если сервис А отвечает кодом `403` в контроллере ожидается исключение уровня 
контроллера (например InvalidRequestParamsException).
- Если сервис А не ответил в течение 30 секунд в контроллере ожидается исключение уровня 
Exception (подразумевается, что дальше оно будет обработано в response с кодом 500)
- Если сервис A ответил кодом 200 должен вызываться метод OrderRepository::setOrderIsPaid()
_Примечание: исключения должны по хорошему отлавливаться на уровне выше контроллера,
и отдавать в response ошибку 403 X-Error-Code или 500_ 

### Бэк – репозиторий
- Если getOrderIsPaid() вернул false ожидается исключение в контроллере 
ожидается исключение уровня контроллера (например InvalidRequestParamsException)
c текстом `Заказ не может быть завершён, проверьте данные`.
- Если getOrderIsPaid() вернул true, метод контроллера (который тестируем) должен
вернуть код 200.

# Системные тесты
_Предполагается, что сумму заказа в форме на фронте поменять нельзя_
- Если ввести синтаксически некорректные данные карты (15 символов в номере, 
два пробела или точку в имени владельца), поля «владелец карты» и «номер карты»
должны отмтиться красной рамкой и заблокироваться кнопка Оплатить. 
(Проверка разблокировки это уже поведение фронта, полагаем что на системном
уровне это уже протестировано).
- Если ввести данные просроченной карты, выводится alert `Оплата не возможна, 
проверьте введёные данные`
- Произвести оплату заведомо действующей картой, получим сообщение вида
`Вы успешно оплатили фильм, <a href="#watch">начать просмотр</a>`

## Примечания:
- Для удешевления проводимых тестов, полагаю есть одно решение: использовать 
тестовые данные, которые обычно предоставляются со стороны сервиса "А", либо
использовать тестовое окружение, предоставляемое обычно тем же сервисом "А" 
(как пример другой URL API или login, при использовании которых реальные 
средства не списываются).
- Есть один скользкий момент: если оплата прошла, а потом оказалось,
что номер заказа и сумма по каким-то причинам не совпали, бэк всё таки должен
вернуть ошибку `Заказ не может быть завершён, проверьте данные` или 200 OK.   
На мой взгляд, сначала нужно проверить возможность осуществления оплаты, записать
в бд с флажком `в обработке`, а потом если не удалось снять деньги – поменять 
статус на `ERROR` и отдать во фронт ошибку 403; если удалось ответить 200 OK    