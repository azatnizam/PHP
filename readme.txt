Как было.
все было одним большим проектом, с кучей вложенных папок.
/project1/api1/file1.php     <- первая версия
/project1/api2/file1_2.php   <- улучшенная версия, или новая версия с дополнительным функционалом.

в этих же файлах непосредственно было ВСЕ и сразу, они отвечали полностью за все в одном файле. 
т.е. разбор параметров, подключение к БД, запрос из базы данных, обработка данных из базы данных.

Минусы у этого были конечно огромные, чем становилось больше кода, и доступ к одним и тем же данным нужен был из разных мест
или использовался код из других API через Copy-Paste или писался еще раз, если нужны были какие то доработки.
Чем больше становилось кода, тем сложнее и сложнее становилось это поддерживать.

Как стало и будет.
Я один большой проект начал делить на микропроекты. 
каждый проект на своем поддомене.
project1.site.ru/api

это нужно для масштабирования проектов, т.е. использование дополнительных серверов, при росте нагрузки, разделения проектов по машинам и т.п.
второй момент, я использовать маршрутизацию.
Так как я использую FatFreeFramework и там есть встроенный роутер.

$f3->route("GET|POST /", "main->index");

создается класс main в котором методы играют роль обработчиков запросов.
Таким образом я могу гибко создавать разные версии Api без разрастания кодовой базы.

следующим этапом, первым но не последним я выделил сущности в отдельные классы. Это классы помощники, которые общаются с базой данных.
но в самом api кода для работы с данными нет, api в этом случае работает как обычный Proxy.

в классы помощники прокидывается через DependencyInjection класс для работы с базой данных \DB\SQL от F3 фраймворка. через который и происходит
взаимодействие с базой данных.

SQL содержит в себе соответственно драйвер базы данных. И таким образом, если сохранить структуру базы данных будь это MySQL, или PostgreSQL все будет
работать точно так же.

Следующими шагами, постепенными :) не революционными, а эволюционными буду внедрять в свой код Interfaces и использовать уже классы через них.
Внедрять сразу в живой рабочий проект я думаю что все таки нельзя. Все делаю итерационно. Шаг за шагом.


>> Согласно PSR именование классов всегда с заглавной буквы
Принято, спасибо!

>> Что такое f3? Что в этой переменной? Какого она типа?
$f3 - это Singleton DI главный компонент F3 фреймворка, который инкапсулирует в себе все все все.

>> Кстати, тайп хинтинга тоже нигде нет.
это был пример с живого, настоящего проекта, на нем версия PHP 7.3 там хинтинг к сожалению работает все еще криво.

>> А если POST.company_id не существует?
это дальше прокинется в класс, запросится компания с NULL параметром, вернется пустой ответ. В ошибку ничего не упадет.
Но и результата не будет. А так как класс этот закрыт SecureController без авторизации в этот класс никто не попадет, 
обычные запросы снаружи сюда не прилетят, будет только запрос с Front'а. в котором company_id с вероятностью 99.999% будет.

>> Клиентский код не должен знать о приложении так много. Используйте Page Controller.
Принято. В новом примере на версии PHP 7.4 попробовал реализовать. Действительно очень красиво получается. Спасибо.

>> Никаких header, конфигов и прочего.
Принято, в новом примере переделал.
