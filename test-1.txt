Тестируем запрос

-- Запрос 1: Посчитать количество фильмов название которых начинается с Терм
SELECT count(name)
FROM public.films
WHERE name like 'Term%';

Создаем таблицу без индексов

CREATE TABLE public.films (
	film_id serial NOT NULL CONSTRAINT film_id_pk PRIMARY KEY,
    name text NOT NULL
);

1. Заполняем таблицу на 10000 строк

Генерируем данные

INSERT INTO public.films (film_id, name)
SELECT
    gs.id,
    random_string((1+random()*40)::integer)
FROM generate_series(1,10000) as gs(id);

План запроса:
Aggregate  (cost=196.00..196.01 rows=1 width=8)
  ->  Seq Scan on films  (cost=0.00..196.00 rows=1 width=21)
        Filter: (name ~~ 'Term%'::text)

Добавляем индекс для "film_id"

CREATE INDEX films_film_id_index ON public.films (film_id);

План запроса:
Aggregate  (cost=196.00..196.01 rows=1 width=8)
  ->  Seq Scan on films  (cost=0.00..196.00 rows=1 width=21)
        Filter: (name ~~ 'Term%'::text)

Добавляем индекс для "name"

CREATE INDEX films_name_index ON public.films (name);

План запроса:
Aggregate  (cost=196.00..196.01 rows=1 width=8)
  ->  Seq Scan on films  (cost=0.00..196.00 rows=1 width=21)
        Filter: (name ~~ 'Term%'::text)

Получилось что наши индксы никак не помогли в данном запроса

Удаляем индексы и данные:
DELETE FROM public.films;
DROP INDEX films_film_id_index;
DROP INDEX films_name_index;

2. Заполняем таблицу на 1000000 строк
Попробуем сначала создать индексы а потом удалять

CREATE INDEX films_film_id_index ON public.films (film_id);
CREATE INDEX films_name_index ON public.films (name);

Генерируем данные

INSERT INTO public.films (film_id, name)
SELECT
    gs.id,
    random_string((1+random()*40)::integer)
FROM generate_series(1,1000000) as gs(id);

План запроса:
Finalize Aggregate  (cost=13271.65..13271.66 rows=1 width=8)
  ->  Gather  (cost=13271.44..13271.65 rows=2 width=8)
        Workers Planned: 2
        ->  Partial Aggregate  (cost=12271.44..12271.45 rows=1 width=8)
              ->  Parallel Seq Scan on films  (cost=0.00..12271.33 rows=41 width=21)
                    Filter: (name ~~ 'Term%'::text)


Удалим индекс для "name"

DROP INDEX films_name_index;

План запроса:
Finalize Aggregate  (cost=13271.65..13271.66 rows=1 width=8)
  ->  Gather  (cost=13271.44..13271.65 rows=2 width=8)
        Workers Planned: 2
        ->  Partial Aggregate  (cost=12271.44..12271.45 rows=1 width=8)
              ->  Parallel Seq Scan on films  (cost=0.00..12271.33 rows=41 width=21)
                    Filter: (name ~~ 'Term%'::text)


Удалим индекс для "film_id"

DROP INDEX films_film_id_index;

План запроса:
Finalize Aggregate  (cost=13271.65..13271.66 rows=1 width=8)
  ->  Gather  (cost=13271.44..13271.65 rows=2 width=8)
        Workers Planned: 2
        ->  Partial Aggregate  (cost=12271.44..12271.45 rows=1 width=8)
              ->  Parallel Seq Scan on films  (cost=0.00..12271.33 rows=41 width=21)
                    Filter: (name ~~ 'Term%'::text)

Никак не поменялось, скорость не зависит от наших индексов

Попробуем другой вид индекса

CREATE INDEX films_name_index ON public.films (name text_pattern_ops);

План запроса:
Aggregate  (cost=8.70..8.71 rows=1 width=8)
  ->  Index Only Scan using films_name_index on films  (cost=0.42..8.45 rows=99 width=21)
        Index Cond: ((name ~>=~ 'Term'::text) AND (name ~<~ 'Tern'::text))
        Filter: (name ~~ 'Term%'::text)

Существенное улучшение, ускорение в 13271.65 / 8.70 = 1 525,47 раза

https://postgrespro.ru/docs/postgresql/9.6/indexes-opclass